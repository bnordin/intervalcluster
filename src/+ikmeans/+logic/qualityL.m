%> @file qualityL.m
%> @brief Provides logic for calculating and saving cluster structrual similarity information
%> @details Provides logic for calculating and saving cluster structrual similarity information
%> @author Ben Nordin
%> @date 2011-09-01
% ======================================================================
%> @brief Provides logic for calculating and saving cluster structrual similarity information
%> @details Provides logic for calculating and saving cluster structrual similarity information
% ======================================================================
classdef qualityL

methods(Static)

	% ======================================================================
	%> @brief Calculate cluster quality
	%> @details Calculate cluster quality based off of the supplied parameters
	%>
	%> @see ikmeans.entity.run
	%> @param r Experiment run information
	%> @retval r Experiment run information
	% ======================================================================
	function r = calculateQuality(r)
		import ikmeans.logic.*;
		import ikmeans.entity.*;
		switch r.parameters.qualityType
			case qualityType.JACCARD
				r = qualityL.jaccardQuality(r);
			otherwise
				r = logL.error(r,sprintf('Unknown quality type: %i',r.parameters.qualityType));
		end % switch
	end % function

	% ======================================================================
	%> @brief Calculate quality using the Jaccard Index method
	%> @details Calculate quality using the Jaccard Index method, which compares the membership information with the answer key
	%>
	%> @see ikmeans.entity.run
	%> @param r Experiment run information
	%> @retval r Experiment run information
	% ======================================================================
	function r = jaccardQuality(r)
		import ikmeans.logic.*;
		import ikmeans.entity.*;

		r = membershipL.load(r,r.parameters.membershipFile);
		% gather data
		actualM = r.project.loadedMembers.values;
		actualClist = unique(actualM);
		calcM = r.project.members.values;
		calcClist = unique(calcM);
		nCluster = max(actualClist);
		nPoints = length(actualM);
		
		% find all actual/calculated membership mappings
		pointMap = zeros(nPoints,2);
		pointMap(:,1) = actualM;
		pointMap(:,2) = calcM;
		uniqueMaps = unique(pointMap,'rows');
		umN = length(uniqueMaps);
		
		% calculate mapping qualities
		uniqueMaps(:,3) = zeros(umN,1);
		uniqueMaps(:,4) = zeros(umN,1);
		uniqueMaps(:,5) = zeros(umN,1);
		for umi=1:umN
			mapCount=0;
			mapCorrect=0;
			for ami=1:nPoints
				if (actualM(ami) == uniqueMaps(umi,1))
					mapCount = mapCount + 1;
					if (calcM(ami) == uniqueMaps(umi,2))
						mapCorrect = mapCorrect + 1;
					end %if
				end %if
				
			end % for ami
			uniqueMaps(umi,4) = mapCorrect;
			uniqueMaps(umi,5) = mapCount;
			if (mapCount > 0)
				uniqueMaps(umi,3) = mapCorrect / mapCount;
			end % if
		end %for umi
%uniqueMaps
		% choose highest-quality unique mappings
		q = qualityL.getNewQuality(r);
		for ci=1:nCluster
			qi = 0;
			quality = 0;
			for umi=1:umN
				
				if (uniqueMaps(umi,2) == ci && quality <= uniqueMaps(umi,3))
					qi = umi;
					quality = uniqueMaps(umi,3);
				end %if
			end %for umi
			if (qi ~= 0)
				finalMaps(ci) = uniqueMaps(qi,1);
				q.values(ci) = quality;
				q.correct(ci) = uniqueMaps(qi,4);
				q.totals(ci) = uniqueMaps(qi,5);
			end %if
			
		end % for ci

		% Record results
		r.project.memberMappings = finalMaps;
		r.results.qualities = q;
%q
	end % function

	% ======================================================================
	%> @brief Initializes a new quality container with default values
	%> @details Initializes a new quality container with default values
	%>
	%> @see ikmeans.entity.run
	%> @see ikmeans.entity.quality
	%> @param r Experiment run information
	%> @retval q The new quality container
	% ======================================================================
	function q = getNewQuality(r)
		import ikmeans.entity.quality;
		q = quality();
		q.name = upper(sprintf('%s_QUALITY',r.project.centroids.name));

		q.values = zeros(r.parameters.nCentroids,1);
		q.correct = zeros(r.parameters.nCentroids,1);
		q.totals = zeros(r.parameters.nCentroids,1);
	end % function		
	
	% ======================================================================
	%> @brief Saves quality results to a file
	%> @details Saves quality results to a file whose filename is generated by the experiment parameters
	%>
	%> @see ikmeans.entity.run
	%> @see ikmeans.entity.quality
	%> @param r Experiment run information
	%> @param q The quality information to save
	%> @retval r Experiment run information
	% ======================================================================
	function r = save(r,q)
		import ikmeans.logic.*
		import ikmeans.data.*
		import ikmeans.entity.*

		logt = logType.SAVE;
		fn = strcat(r.parameters.resultsPath,filesep,lower(q.name),r.parameters.extension);
		r = logL.info(r,logt,sprintf('Saving quality to: %s',fn));
		
		r = qualityD.save(r,r.results.qualities,fn);

	end % function
	
end % methods
end % classdef

